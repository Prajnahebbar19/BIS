# -*- coding: utf-8 -*-
"""Cuckoo_Search.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1A4rubdYjgcXkfvzEB1uvSaf-q8vkjMN9
"""

# prompt: code for cuckoo search algorithm

import numpy as np
import random
import math

class CuckooSearch:
  """
  Cuckoo Search algorithm implementation.

  Attributes:
    n_cuckoos: Number of cuckoos in the population.
    n_dimensions: Number of dimensions of the search space.
    pa: Probability of replacing a nest.
    upper_bound: Upper bound of the search space.
    lower_bound: Lower bound of the search space.
    objective_function: The function to be minimized.
  """

  def __init__(self, n_cuckoos, n_dimensions, pa, upper_bound, lower_bound, objective_function):
    self.n_cuckoos = n_cuckoos
    self.n_dimensions = n_dimensions
    self.pa = pa
    self.upper_bound = upper_bound
    self.lower_bound = lower_bound
    self.objective_function = objective_function
    self.nests = np.random.uniform(low=self.lower_bound, high=self.upper_bound, size=(self.n_cuckoos, self.n_dimensions))

  def levy_flight(self):
    """Generates a random step based on a Levy distribution."""
    sigma = (math.gamma(1 + 0.5) * np.sin(math.pi * 0.5 / 2) /
            (math.gamma((1 + 0.5) / 2) * 0.5 ** (0.5 - 1))) ** (1 / 0.5)
    u = np.random.randn(self.n_dimensions) * sigma
    v = np.random.randn(self.n_dimensions)
    step = u / (np.abs(v) ** (1 / 0.5))
    return step

  def get_fitness(self, nest):
    """Calculates the fitness of a nest (solution)."""
    return self.objective_function(nest)

  def update_nests(self):
    """Updates the nests using the cuckoo search rules."""
    for i in range(self.n_cuckoos):
      # Generate a new solution (cuckoo) by Levy flight
      step = self.levy_flight()
      new_nest = self.nests[i] + step * np.random.rand()
      # Keep within the search space bounds
      new_nest = np.clip(new_nest, self.lower_bound, self.upper_bound)

      # Compare with an existing nest and replace if better
      if self.get_fitness(new_nest) < self.get_fitness(self.nests[i]):
        self.nests[i] = new_nest

    # Abandon some nests randomly
    for i in range(self.n_cuckoos):
      if random.random() < self.pa:
        self.nests[i] = np.random.uniform(low=self.lower_bound, high=self.upper_bound, size=self.n_dimensions)

  def run(self, max_iterations):
    """Runs the Cuckoo Search algorithm."""
    for _ in range(max_iterations):
      self.update_nests()
    best_nest_index = np.argmin([self.get_fitness(nest) for nest in self.nests])
    return self.nests[best_nest_index], self.get_fitness(self.nests[best_nest_index])

# Example usage:
def sphere_function(x):
  """Example objective function (Sphere function)."""
  return np.sum(np.square(x))

# Define problem parameters
n_cuckoos = 25
n_dimensions = 5
pa = 0.25
upper_bound = 5
lower_bound = -5
max_iterations = 100

# Initialize and run the algorithm
cs = CuckooSearch(n_cuckoos, n_dimensions, pa, upper_bound, lower_bound, sphere_function)
best_solution, best_fitness = cs.run(max_iterations)

print("Best solution found:", best_solution)
print("Best fitness value:", best_fitness)