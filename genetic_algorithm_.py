# -*- coding: utf-8 -*-
"""Genetic_Algorithm .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1adc9_9TV35u4RlRUMP_VxdBdkCCVWDUP
"""

import numpy as np
import random

# Define the objective function
def fitness_function(x):
    return x**2

# Initialize parameters
population_size = 100
mutation_rate = 0.01
crossover_rate = 0.7
num_generations = 50
range_min, range_max = -10, 10

# Create initial population
def initialize_population(size, range_min, range_max):
    return np.random.uniform(range_min, range_max, size)

# Evaluate fitness
def evaluate_fitness(population):
    return np.array([fitness_function(x) for x in population])

# Selection using roulette wheel method
def selection(population, fitness_values):
    total_fitness = np.sum(fitness_values)
    probabilities = fitness_values / total_fitness
    selected_indices = np.random.choice(range(len(population)), size=2, p=probabilities)
    return population[selected_indices]

# Crossover to produce offspring
def crossover(parent1, parent2):
    if random.random() < crossover_rate:
        alpha = random.random()
        return alpha * parent1 + (1 - alpha) * parent2
    return parent1  # No crossover, return one parent

# Mutation of an offspring
def mutate(offspring, mutation_rate, range_min, range_max):
    if random.random() < mutation_rate:
        return np.random.uniform(range_min, range_max)  # Replace with a new random value
    return offspring

# Main Genetic Algorithm function
def genetic_algorithm():
    # Step 1: Initialize population
    population = initialize_population(population_size, range_min, range_max)

    best_solution = None
    best_fitness = float('-inf')

    # Run for a number of generations
    for generation in range(num_generations):
        # Step 2: Evaluate fitness
        fitness_values = evaluate_fitness(population)

        # Update the best solution found
        current_best_idx = np.argmax(fitness_values)
        current_best_fitness = fitness_values[current_best_idx]

        if current_best_fitness > best_fitness:
            best_fitness = current_best_fitness
            best_solution = population[current_best_idx]

        # Step 3: Create the next generation
        new_population = []

        for _ in range(population_size):
            parent1, parent2 = selection(population, fitness_values)
            offspring = crossover(parent1, parent2)
            offspring = mutate(offspring, mutation_rate, range_min, range_max)
            new_population.append(offspring)

        population = np.array(new_population)

    return best_solution, best_fitness

# Run the Genetic Algorithm
best_x, best_value = genetic_algorithm()
print(f"The best solution found is x = {best_x:.4f} with a fitness value of f(x) = {best_value:.4f}")